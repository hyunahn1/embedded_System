# GPIO

## GPIO의 개념

### 쉽게 이해하기

**GPIO = 만능 소켓**

전기 콘센트에 여러 가지를 꽂을 수 있듯이, GPIO 핀도 여러 용도로 쓸 수 있다:
- LED를 켜는 출력으로 쓸 수도 있고
- 버튼을 읽는 입력으로 쓸 수도 있고
- 통신(UART, I2C)으로도 쓸 수 있다

**핵심:** 핀의 역할을 프로그램(코드)으로 정한다!

```c
void setup() {
    pinMode(13, OUTPUT);     // 13번 핀을 출력으로 설정
    pinMode(12, INPUT);      // 12번 핀을 입력으로 설정
    digitalWrite(13, HIGH);  // 13번 핀을 켜기 (3.3V 출력)
    digitalWrite(13, LOW);   // 13번 핀을 끄기 (0V 출력)
}
```

### 기술적 정의

GPIO는 **General-Purpose Input/Output**의 줄임으로, **범용 입출력 핀**을 말한다.

여기서 범용이라는 것은 여러 용도로 사용할 수 있다는 의미에서 붙여진 것이다. 즉, 어떤 핀의 용도가 입력이냐 출력이냐 하는 것이 마이크로컨트롤러에서 수행되는 프로그램에 의해 결정된다.

예를 들어, 어떤 핀이 입력으로 설정될 경우, 그 입력 핀을 칩 내부에 있는 풀업 저항을 통해 마이크로컨트롤러의 '+' 전원 전압에 연결되게 할지의 여부도 프로그램에 의해 결정된다.

### 디지털 출력으로 사용

GPIO 핀은 디지털 출력으로 많이 사용된다. 즉, 외부 장치나 부품을 ON/OFF 하는 데에 사용된다.

GPIO 핀에는 LED와 같은 부품을 직접 연결하여 이를 ON/OFF 하거나, 포토커플러 또는 릴레이(계전기)를 연결하여 이들을 ON/OFF 하는 방식을 사용하여 어떤 장치에 큰 전압이나 전류가 공급되거나 차단되도록 제어하는 역할을 수행한다.

**전압 레벨:**
- **HIGH 출력:** 마이크로컨트롤러의 전원 전압 (5V 또는 3.3V)이 핀에 나타남
- **LOW 출력:** 0V가 핀에 나타남

**호환성 주의:**
- 5V 마이크로컨트롤러는 3.3V의 전압으로도 대부분 동작하지만, 그 반대로 동작하지 않는 경우도 있다.

### 디지털 입력으로 사용

마이크로컨트롤러로 하여금 들어오는 입력에 반응하여 어떤 동작을 수행하게 하려면, GPIO를 디지털 입력으로 설정한다.

마이크로컨트롤러가 어떤 디지털 입력을 읽으면 입력은 **HIGH 또는 LOW** 중에 하나로 판단된다.

**판정 기준:**

보통, 디지털 입력 핀에 들어오는 입력 전압의 크기가 마이크로컨트롤러의 전원 전압의 문턱전압보다 크면 HIGH가 되고 작으면 LOW가 된다.

**전압 레벨 호환성:**

크기가 3.3V인 디지털 출력을 5V 입력에 연결하는 것은 괜찮다. (3.3V의 HIGH 전압이 2.5V의 문턱전압보다 크기 때문이다.)

그러나 어떤 3.3V 디지털 입력이 5V 입력 허용 능력을 가지고 있지 않다면, 그 디지털 입력에 5V 디지털 출력을 연결하면 안 된다.

## Pin Modes

### 1. 입력 모드

#### 1-1. 플로팅(부동, Floating)

**쉽게 이해하기:**

허공에 둥둥 떠있는 풍선 같은 상태. 바람(노이즈)만 불어도 이리저리 흔들린다.
- 아무것도 연결 안 함 → 값이 0 되었다 1 되었다 제멋대로
- 마치 TV 안테나가 방송국 신호 대신 주변 잡음만 주워듣는 것과 같음

**기술적 설명:**

핀이 전원(VCC)에 연결되지도 않고, 접지(GND)에도 연결되지 않은 소위 '붕 떠 있는' 상태를 말한다.

이 상태에서는 주변의 작은 정전기(노이즈)만 스쳐도 0이 되었다가 1이 되었다가 제멋대로 값이 튄다. 마치 안테나처럼 주변 전파를 모두 흡수해버리는 것이다.

이는 **High Impedance (Hi-Z, 고임피던스)**, 즉 전기적으로 절연에 가까운 상태라는 것이다. 핀으로 흐르는 전류가 거의 없기 때문에 외부 회로에 영향을 주지 않는다.

**문제점:**

입력이 Open(연결 안되는 상태)되면 전압 레벨이 확정되지 않아, MCU가 오작동하거나 내부 로직의 스위칭이 빈번하게 발생해 전력 소모가 늘어나게 된다.

#### 1-2. 풀업 (Pull-Up)

**쉽게 이해하기:**

스프링으로 천장(VCC)에 매달아 둔 상태. 가만히 두면 항상 위(1)에 있다.
- 평소: 핀 = 1 (HIGH)
- 버튼 누르면: 강제로 바닥(GND)으로 끌어내림 → 핀 = 0 (LOW)

**기술적 설명:**

MCU 내부에서 핀을 전원(3.3V/5V) 쪽에 약한 힘으로 잡아당겨 놓고 있다. 아무것도 안 하면 전압이 높으므로 **기본값은 1**이다. 그러다가 스위치를 눌러서 강제로 GND로 끌어내려야 비로소 0이 된다.

**내부 회로:** 핀과 VCC 사이에 내부 저항($R_{PU}$, 보통 $30k\Omega \sim 50k\Omega$)이 연결된다.

**Active Low:** 버튼을 누르면 전류가 저항을 거치지 않고 바로 GND로 빠지기 때문에 핀의 전압은 0V가 된다.

**특징:**
- 노이즈에 강하며, 임베디드 시스템에서 가장 일반적으로 사용되는 버튼 입력 방식이다.
- 대부분 MCU에서 지원된다.

#### 1-3. 풀다운 (Pull-Down)

**쉽게 이해하기:**

무거운 추로 바닥(GND)에 눌러 둔 상태. 가만히 두면 항상 아래(0)에 있다.
- 평소: 핀 = 0 (LOW)
- 버튼 누르면: 위(VCC)로 끌어올림 → 핀 = 1 (HIGH)

**기술적 설명:**

MCU 내부에서 핀을 접지(0V) 쪽에 약한 힘으로 묶어두고, 아무것도 안 하면 **기본값은 0**이다. 스위치를 누르면 풀업과 반대로 1이 된다.

**내부 회로:** 핀과 GND 사이에 내부 저항($R_{PD}$)이 연결된다.

**Active High:** 버튼을 누르면 VCC 전압이 핀으로 인가되어 Logic 1이 된다.

**특징:**
- 사람의 직관(누르면 1)과는 잘 맞지만, 회로 설계 관습상 풀업보다는 덜 쓰인다.
- 과거 일부 MCU는 내부 풀다운을 지원하지 않는 경우도 있었으나, 최신 STM32 등은 둘 다 지원한다.

### 2. 출력 모드

#### 2-1. 푸시-풀 (Push-Pull)

**쉽게 이해하기:**

엘리베이터 문처럼 위아래 두 개의 스위치가 있다.
- HIGH(1) 출력: 위쪽 문 열림 → 전기를 밖으로 밀어냄 (PUSH)
- LOW(0) 출력: 아래쪽 문 열림 → 전기를 안으로 당김 (PULL)

둘 다 **적극적으로** 전압을 만들어낸다!

**기술적 설명:**

가장 일반적인 출력 방식이다.

MCU 내부에 두 개의 스위치가 위아래로 달려있다.
- **HIGH(1)를 출력할 때:** 위쪽 스위치를 켜서 VCC 전류를 밖으로 밀어낸다(PUSH)
- **LOW(0)를 출력할 때:** 아래쪽 스위치를 켜서 밖의 전류를 안으로 당겨와서(PULL) GND로 버린다.

즉, 0과 1 모든 상태에서 적극적인 움직임을 가져간다.

0V와 3.3V(또는 5V)를 아주 빠르고 강력하게 전환하며, LED 켜기, 다른 칩에 신호 보내기 등과 같은 일반적인 출력 상황에서 사용한다.

**주의사항:**

여러 개의 푸시-풀 출력을 하나의 선에 묶으면 안 된다. (하나는 5V를 밀고, 하나는 0V로 당기면 쇼트가 나기 때문에 칩이 탄다)

#### 2-2. 오픈-드레인 (Open-Drain)

**쉽게 이해하기:**

아래로 끌어내리기(0)는 잘하지만, 위로 밀어올리기(1)는 못 하는 외팔이 스위치.
- LOW(0) 출력: 바닥으로 확실히 끌어내림
- HIGH(1) 출력: 그냥 놔둠 (외부 풀업 저항이 필요)

**기술적 설명:**

Down(0)은 잘하지만 UP(1)을 하지 못해서 저항이 필요하다.

MCU 내부에 아래쪽(GND)으로 연결하는 스위치 하나만 있다.
- **LOW(0)를 출력할 때:** 스위치를 닫아서 바닥(GND)으로 끌어내린다.
- **HIGH(1)를 출력할 때:** 스위치를 연다. 그런데 위쪽에서 전기를 공급해주는 것이 없으니, 핀은 전기가 끊긴 플로팅(둥둥 뜬) 상태가 되어버린다.

**왜 이런 방식을 사용하는가?**

1. **전압이 다른 장치와 대화할 때 (Level Shifting):**
   내 MCU가 3.3V인데, 상대방 부품이 5V로 동작한다면, 오픈-드레인으로 설정하고 외부 풀업 저항을 5V에 연결하면 안전하게 5V 신호를 줄 수 있다. (푸시-풀로 3.3V를 쏘면 상대방이 인식 못 할 위험 있음)

2. **여러 명이 한 줄로 대화할 때 (I2C 통신):**
   여러 장치가 하나의 선을 공유할 때, 누군가 0으로 확 끌어내리면 전체가 0이 되는 구조(Wired-AND)를 만들 수 있어서 통신 충돌을 막는다.

### 3. 대체 기능 설정 (Alternate Function Configuration)

**쉽게 이해하기:**

핀을 "다목적실"이라고 생각해보자.
- **GPIO 모드:** CPU가 직접 관리하는 빈 방 (불 끄고 켜기만 함)
- **AF 모드 (UART 설정):** "오늘부터 여기는 통신실!" → 통신 전문가(UART 하드웨어)가 방을 독점
- **AF 모드 (Timer 설정):** "오늘부터 여기는 시계방!" → 시간 전문가(Timer 하드웨어)가 방을 독점

핀의 제어권을 CPU에서 → 전문 하드웨어로 넘겨주는 것!

**기술적 설명:**

**대체 기능(AF)**은 핀의 제어권을 CPU가 아닌 내부 장치에게 넘겨주는 것이다.

마이크로컨트롤러(MCU) 안에는 CPU 말고도 수많은 **'Peripherals'**들이 있다:
- UART: 통신
- Timer: 시간/PWM
- ADC: 아날로그 측정
- SPI/I2C: 고속 통신

하지만 MCU 겉에 있는 핀의 개수는 한정적이다. (예: 내장 기능은 100개인데, 핀은 48개뿐) 그래서 핀 하나를 상황에 따라 용도를 바꿔가며(Alternate) 써야 한다.

#### 3-1. 작동원리

핀 내부에 있는 **스위치(Multiplexer, 줄여서 MUX)**를 사용한다.

- **GPIO 모드:** 스위치가 [Output Data Register] 쪽에 연결된다. 우리가 코드(CPU)로 0, 1을 쓰면 핀이 바뀐다.
- **AF 모드:** 스위치가 [내부 장치(예: Timer)] 쪽에 연결된다. 이제부터는 CPU가 `HAL_GPIO_WritePin`으로 아무리 명령해도 핀은 듣지 않는다. 대신 내부에 있는 Timer 하드웨어가 자동으로 신호를 0, 1, 0, 1 하며 만들어낸다.

#### 3-2. 사용 예시

| 기능 | 역할 | CPU의 역할 |
|------|------|------------|
| USART (TX/RX) | PC나 다른 칩과 글자를 주고받음 | "야, 'Hello'라고 보내!" 라고 명령만 하면, 핀 제어는 UART 하드웨어가 알아서 초고속으로 전압을 흔들어서 보냄 |
| PWM (Timer) | 모터 속도 제어, LED 밝기 조절 | "듀티비 50%로 쏴!" 라고 하면, Timer 하드웨어가 알아서 핀을 껐다 켰다 반복함. (CPU는 딴짓 가능) |
| SPI / I2C | 센서값 읽기 | "센서값 읽어와" 하면, 통신 모듈이 알아서 클럭(Clock) 신호를 핀으로 내보내고 데이터를 받아옴 |

#### 3-3. 설정 방법

MCU 핀은 변신 로봇과 같아서, "너 오늘부터 무슨 역할 해!" 라고 딱 정해줘야 한다. 이걸 핀 맵(Pin Map) 설정이라고 한다.

보통 STM32 같은 칩의 데이터시트를 보면, 핀 하나에 할당된 기능이 표로 나와 있다.

**예시: PA9 핀의 운명**
- AF0: 시스템 기능
- AF1: 타이머 1번 (TIM1)
- AF4: 시리얼 통신 (USART1_TX)
- AF7: 또 다른 통신 (USART1)

### 4. 아날로그 모드 (Analog Mode)

**쉽게 이해하기:**

디지털 = 흑백 사진 (0 아니면 1)
아날로그 = 컬러 사진 (0.5V, 1.25V, 2.78V... 무한한 값)

아날로그 모드는 "0인가 1인가?" 대신 "정확히 몇 V인가?"를 측정하는 모드!

**기술적 설명:**

'0과 1의 흑백 논리'를 벗어나는 모드. 전압의 크기를 있는 그대로 받아서 계산하는 ADC에게 넘겨준다.

#### 4-1. 슈미트 트리거 (Schmitt Trigger)

디지털 입력 모드일 때, 핀 내부에는 **'슈미트 트리거(Schmitt Trigger)'**라는 문지기가 있다.

이 문지기의 역할은 들어오는 전압을 감시하다가 "이건 0이야!", "이건 1이야!"라고 딱 잘라 판단해서 CPU에게 던져주는 것이다.

하지만 아날로그 모드로 설정을 하게 되면, 슈미트 트리거를 아예 꺼버린다(Disconnect). 그리고 핀으로 들어오는 전압을 가공하지 않고 날 것 그대로 칩 내부의 **ADC(아날로그-디지털 변환기)**로 보낸다.

**왜 굳이 디지털 회로를 끊을까?**

그냥 연결해두고 ADC도 쓰면 안 되나? 싶지만, 디지털 회로를 끊는 아주 중요한 이유 2가지가 있다.

**1. Power Saving (전력 절약):**

디지털 회로(0과 1을 판별하는 회로)는 **어중간한 전압(Middle Voltage)**을 제일 싫어한다.
- 0V나 3.3V가 들어오면 편안해한다.
- 하지만 만약 1.65V 같은 애매한 전압이 들어오면?

슈미트 트리거가 "어? 0인가? 1인가?" 하면서 혼란에 빠진다. 이 과정에서 내부 트랜지스터가 켜졌다 꺼졌다를 미친 듯이 반복하거나, 반쯤 열린 상태가 되어 전류가 줄줄 새게 된다(Leakage Current). 그렇게 배터리가 순식간에 닳아버리고 만다.

**2. Noise Reduction (노이즈 감소):**

디지털 회로가 작동할 때 발생하는 미세한 전기적 떨림(스위칭 노이즈)이, 아주 예민하고 섬세해야 할 아날로그 측정값에 방해가 될 수 있다. 그래서 아예 연결을 끊어버리는 것이다.

#### 4-2. 언제 쓸까?

핀을 통해 **'연속적인 값'**을 다루고 싶을 때 쓴다.

**전압 측정 (ADC 입력):**
- 온도 센서, 조도 센서, 배터리 잔량 확인 등
- "지금 1이야 0이야?"가 아니라 **"지금 1.25V야? 아니면 2.78V야?"**를 알고 싶을 때

**파형 출력 (DAC 출력):**
- 오디오 잭으로 소리를 내보내거나, 부드러운 전압 곡선을 만들 때

## Configuration

### 1. Speed / Slew Rate

#### 1-1. 쉽게 이해하기

**자동차 가속 페달 비유:**
- **Low Speed:** 천천히 부드럽게 가속 (연비 좋음, 소음 적음)
- **High Speed:** 급격하게 가속 (빠르지만 시끄럽고 떨림)

GPIO도 마찬가지! 0V → 3.3V로 전압을 올릴 때 얼마나 급하게 올릴지를 결정하는 설정.

```
Low Speed:   0V ___/‾‾‾‾ 3.3V  (완만한 언덕)
High Speed:  0V ___|‾‾‾‾ 3.3V  (수직 절벽)
```

#### 1-2. 정의 (Definition)

기술적으로 **출력 신호가 0(0V)에서 1(3.3V)로 변할 때, 전압이 상승하는 기울기 ($dV/dt$)**를 말한다.

- **High Speed:** 전압이 수직 절벽처럼 순식간에 솟구친다. 통신 속도가 빠르지만 noise가 크게 나거나 ringing, overshoot이 나올 수 있다.
- **Low Speed:** 전압이 완만한 언덕처럼 비스듬히 올라간다. 안정적이지만 시간이 걸린다.

MCU 입장에서 'Speed' 설정은 **"이 핀의 전압을 얼마나 세게(급하게) 밀어 올릴 것인가?"**를 정한다. 주파수(Frequency) 자체가 아니라, 신호의 '모서리(Edge)'를 얼마나 날카롭게 만들지를 결정하는 것이다.

#### 1-3. 보편적 기준

**Low Speed (기본값):**
- 용도: LED 켜기, 버튼 입력, 일반적인 스위치 제어
- 대부분 이걸 쓰면 된다. 안전하고 조용하니까.

**Medium/High Speed:**
- 용도: SPI, I2C 통신처럼 초당 수백만 번 신호를 주고받아야 할 때
- 데이터가 깨지지 않으려면 어쩔 수 없이 빨리 전환해야 한다.

**Very High Speed:**
- 용도: 수십 MHz 이상의 초고속 통신(메모리 인터페이스 등)
- 필요할 때만 제한적으로 사용

### 2. Drive Strength

#### 2-1. 쉽게 이해하기

**수도관 비유:**
- **Low Drive:** 가는 수도관 → 물이 조금씩 나옴 (약한 전류)
- **High Drive:** 굵은 수도관 → 물이 세게 나옴 (강한 전류)

GPIO 핀도 마찬가지로, 얼마나 많은 전류를 "밀어낼 수 있는가"를 설정하는 것!

LED 1개 켜기: 가느다란 수도관(Low Drive)으로 충분
LED 10개 켜기: 굵은 수도관(High Drive) 필요

#### 2-2. 정의

GPIO 핀이 출력 모드일 때, 전압 레벨(Logic High/Low)을 유지하면서 흘려보낼 수 있는(Source) 최대 전류량 또는 빨아들일 수 있는(Sink) 최대 전류량을 의미한다.

단순히 "전류를 보낸다"가 아니라, **"정해진 전압 범위($V_{OH}, V_{OL}$)를 깨뜨리지 않고 버틸 수 있는 부하(Load)의 한계"**를 설정하는 것이다.

- $V_{OH}$ (Output High Voltage): High로 인정받기 위한 최소 전압 (예: 2.4V 이상)
- $V_{OL}$ (Output Low Voltage): Low로 인정받기 위한 최대 전압 (예: 0.4V 이하)

#### 2-3. 회로적 원리 (Internal Mechanism)

**내부 저항 ($R_{DS(on)}$)의 변화:**

MCU 내부에는 출력을 담당하는 트랜지스터(MOSFET)가 있다. Drive Strength 설정은 이 트랜지스터의 내부 저항값을 조절하는 것과 같다.

- **Low Drive Strength:** 내부 트랜지스터의 저항이 크다. (수도관이 좁다 → 전류가 적게 흐름)
- **High Drive Strength:** 내부 트랜지스터의 저항이 작다. (수도관이 넓다 → 전류가 많이 흐름)

#### 2-4. 문제점 및 고려사항

**전압 강하 (Voltage Drop):**

부하(Load)가 전류를 많이 필요로 하는 부품(예: 밝은 LED, 모터 드라이버 입력 등)인데, Low Drive로 설정하면 어떻게 될까?

→ 옴의 법칙($V=IR$)에 의해, MCU 내부 저항에서 전압을 다 까먹는다.

그 결과, 3.3V를 출력하라고 명령했는데, 핀 밖으로 나가는 실제 전압은 2.5V 정도로 뚝 떨어진다. 그렇게 되면 연결된 상대방 부품이 "어? 이거 3.3V(High) 맞아? 2.5V면 애매한데?"라며 신호를 인식 못 할 수 있다.

**팬 아웃 (Fan-out) 부족:**

한 핀에 여러 개의 게이트(다른 칩의 입력 핀)를 병렬로 연결해야 할 때, 구동 능력이 부족하면 신호가 전달되지 않는다.

**과도한 전류와 노이즈 (High 설정의 부작용):**

필요 없는데 무조건 High Drive로 설정하면?

→ 스위칭 순간에 Ground Bounce(지면 반동) 노이즈가 발생하여, 옆에 있는 핀의 신호까지 흔들릴 수 있다. 또한 MCU 자체의 발열과 전력 소모가 증가한다.

#### 2-5. 적용 가이드

**데이터시트 확인:**
- 연결하려는 부품이 몇 mA를 필요로 하는지 확인한다.
- 보통 일반적인 신호 전달은 2mA~4mA면 충분하다.

**LED 구동 시:**
- LED는 전류를 많이 먹으므로(보통 5~20mA), 계산된 저항 값에 맞춰 Medium이나 High로 설정해야 불이 밝게 켜진다.

**일반 통신:**
- 대부분 Low나 Medium으로 충분하다.
- 무조건 High로 두는 것은 하드웨어적으로 아마추어 같은 설정이다.

## 2-3. Pin Remapping (핀 재배치)

 1. 쉽게 이해하기 (비유)
    MCU를 아파트 건물이라고 생각해보자.
    
    - **내부 주변장치(UART, Timer 등)**: 각 세대(101호, 102호...)에 사는 주민들
    - **핀(Pin)**: 건물 밖으로 나가는 현관문
    - **Pin Remapping**: 주민이 사용하는 현관문을 바꿔주는 것
    
    예를 들어:
    - 평소: UART는 1번 현관문으로 나간다. (기본 설정)
    - 문제 상황: "어? 1번 현관문에 다른 사람(Timer)도 나가야 하네?"
    - 해결책: "그럼 UART는 2번 현관문으로 나가세요!" (Remapping 설정)
    
    **핵심**: 집 안의 주민(기능)은 그대로인데, 밖으로 나가는 문만 바꿔주는 것!

 2. 정의
    MCU 내부의 주변장치(Peripheral: UART, Timer, SPI 등) 신호가 연결되는 물리적인 핀(Pin)의 위치를 변경하는 기능이다.
    
    모든 주변장치는 제조사가 정해둔 '기본 핀(Default)'이 있지만, 설정(레지스터 조작)을 통해 미리 지정된 '대체 핀(Remap Pin)'으로 신호 경로를 바꿀 수 있다.

 3. 동작 메커니즘
    철도 전환기(Switch)처럼 작동한다:
    
    MCU 내부에는 신호의 경로를 선택할 수 있는 **디지털 스위치(멀티플렉서, MUX)**가 있다.
    
    ```
    [UART 신호] ──┐
                  ├─ 스위치 ──→ 1번 핀 (기본)
                  └─────────→ 2번 핀 (대체)
    ```
    
    코드에서 레지스터(AFIO 등)의 특정 비트를 1로 설정하면, 내부 스위치가 "딸깍" 하고 전환되어 신호가 다른 핀으로 나가게 된다.
    
    **중요**: 마음대로 아무 핀으로나 옮길 수 없다! 제조사가 미리 정해둔 "대체 핀" 옵션 중에서만 선택 가능하다.

 4. 언제 사용할까?
    4-1. 핀 충돌이 생겼을 때
        ```
        문제: UART와 Timer 둘 다 PA9 핀을 쓰고 싶어한다.
        해결: UART를 PB6으로 리매핑한다.
        결과: 둘 다 동시에 사용 가능!
        ```
    
    4-2. PCB 배선이 복잡할 때
        회로 기판을 설계하다 보니 기본 핀으로는 선을 연결하기 어려운 경우, 배선하기 편한 다른 핀으로 옮긴다.
        
        (마치 도로가 막혀서 우회로를 뚫는 것과 같다)

 5. 실제 예시 (STM32 기준)
    ```c
    // UART1의 TX 핀을 기본(PA9)에서 대체(PB6)로 변경
    __HAL_AFIO_REMAP_USART1_ENABLE();  // 리매핑 활성화
    
    // 이제 UART1 TX는 PA9가 아닌 PB6로 신호가 나간다!
    ```

## 2-4. EXTI (External Interrupt / 외부 인터럽트)

 1. 쉽게 이해하기 (비유)
    **문지기(CPU)와 초인종(EXTI) 비유**
    
    ### 폴링(Polling) 방식 = 문 앞에서 계속 확인하기
    ```c
    while(1) {
        if (버튼이_눌렸나?)    // 1초마다 확인
            손님_맞이();
        else
            다른_일_하기();     // 하지만 계속 확인해야 함
        delay(1초);
    }
    ```
    → CPU가 계속 "버튼 눌렸나? 버튼 눌렸나?" 반복 확인
    → 확인하는 1초 사이에 버튼 눌리면 놓칠 수도 있음
    → CPU가 쉴 수 없어서 전력 낭비
    
    ### 인터럽트(EXTI) 방식 = 초인종 울리면 달려가기
    ```c
    // CPU는 평소에 다른 일 하다가...
    main() {
        TV_보기();
        요리_하기();
        청소_하기();  // ← 이거 하는 중에...
    }
    
    // 버튼 누르면 자동으로 이 함수 실행!
    void 버튼_인터럽트_핸들러() {
        // "띵동!" 하고 초인종 울림
        손님_맞이();              // 급하게 처리
        // 다시 청소_하기()로 돌아감
    }
    ```
    → 버튼이 눌리는 순간 하드웨어가 자동으로 CPU에게 알림
    → CPU는 평소에 다른 일 하다가, 알림 오면 즉시 반응
    → 놓칠 일이 없고, 전력도 절약

 2. 정의 (기술적 관점)
    **비동기적 이벤트 처리 (Asynchronous Event Handling)**:
    
    CPU의 프로그램 카운터(PC) 흐름과 무관하게, 외부 GPIO 핀의 상태 변화(Edge)가 감지되면 하드웨어적으로 CPU에 예외(Exception)를 요청하는 메커니즘이다.
    
    **이벤트 구동 (Event-Driven)**:
    
    폴링(Polling) 방식이 소프트웨어적으로 주기적인 상태 검사(Status Check)를 수행하는 '동기식(Synchronous)'이라면, EXTI는 사건 발생 시 즉시 반응하는 방식이다.

 3. 동작 메커니즘
    ### 3-1. 쉬운 설명
    **EXTI = GPIO 핀의 상태 변화를 감지하면, CPU에게 자동으로 "이봐요!" 하고 부르는 시스템**
    
    언제 "이봐요!" 할지 설정 가능:
    ```
    Rising Edge (상승 에지):   0 → 1 변할 때 (버튼 누르는 순간)
    Falling Edge (하강 에지):  1 → 0 변할 때 (버튼 떼는 순간)
    Both (양쪽):                둘 다 반응
    ```
    
    동작 순서:
    ```
    1. [GPIO 핀] 버튼 눌림! (0→1)
         ↓
    2. [에지 검출기] "변화 감지했어요!" → Pending Bit = 1
         ↓
    3. [NVIC] "CPU님, 급한 일 있어요!" (우선순위 체크)
         ↓
    4. [CPU] 하던 일 멈추고 → 현재 상태 백업 → 인터럽트 처리 함수로 점프
         ↓
    5. [ISR 함수] 버튼_인터럽트_핸들러() 실행
         ↓
    6. [CPU] 다시 원래 하던 일로 복귀
    ```
    
    ### 3-2. 기술적 설명 (하드웨어 레벨)
    **Edge Detector (에지 검출기)**:
    
    GPIO 핀으로 들어오는 신호를 모니터링하다가 설정된 변화(Rising/Falling)가 감지되면, 이를 래치(Latch)하여 'Pending Bit'를 1로 설정한다.
    
    **NVIC (Nested Vectored Interrupt Controller)**:
    
    CPU 코어 옆에 붙어 있는 인터럽트 관리 장치다. 여러 개의 인터럽트가 동시에 터졌을 때 **우선순위(Priority)**를 중재하고, CPU에게 "하던 일을 멈추라"는 신호를 보낸다.
    
    **Context Switch (문맥 교환)**:
    
    CPU는 현재 실행 중인 레지스터 값(Context)을 스택(Stack)에 백업하고, 사전 정의된 **인터럽트 벡터 테이블(Vector Table)**을 참조하여 해당 ISR(Interrupt Service Routine) 함수로 점프한다.

 4. 공학적 의의 (왜 사용할까?)
    ### 4-1. 결정론적 응답성 (Real-time Determinism)
    **쉽게**: 자동차 충돌 감지, 비상 정지 버튼처럼 "절대 놓치면 안 되는" 이벤트 처리
    
    **기술적**: 임베디드 시스템(특히 자동차 ECU)에서는 센서 신호에 대해 $x$ 마이크로초 이내에 반응해야 한다는 요구사항(Hard Real-time)이 있다.
    
    - **폴링 방식**: Loop 주기에 따라 반응 속도가 달라짐 (Jitter 발생)
      ```
      최악의 경우: 루프 한 바퀴 돌고 나서야 감지 (수십 ms 지연 가능)
      ```
    
    - **EXTI 방식**: 하드웨어적으로 즉시 반응하므로 응답 시간을 보장할 수 있다.
      ```
      보통: 수 마이크로초 이내 반응 (1,000배 이상 빠름!)
      ```
    
    ### 4-2. 전력 효율성 (Power Efficiency)
    **쉽게**: CPU가 잠들어 있다가 필요할 때만 깨어남 → 배터리 오래 감
    
    **기술적**: 폴링은 감시를 위해 CPU가 계속 Active 상태를 유지해야 하지만, EXTI를 사용하면 평소에 CPU를 Stop 모드나 Sleep 모드로 두어 전류 소모를 $\mu A$ (마이크로암페어) 단위로 줄일 수 있다.
    
    ```
    폴링 모드:   CPU 항상 켜짐 → 수십 mA 소비
    EXTI 모드:   CPU 대부분 절전 → 수 μA 소비 (1,000배 차이!)
                 인터럽트 발생 시에만 Wake-up
    ```
    
    → 배터리로 동작하는 IoT 센서, 웨어러블 기기에서 필수적!
    
    ### 4-3. CPU 효율성
    **폴링**: CPU가 단순 확인에 수십 %의 시간 낭비
    **인터럽트**: CPU는 다른 중요한 일(연산, 통신 등) 하다가, 필요할 때만 반응

 5. 주의사항: 채터링/바운싱 (Bouncing) 현상
    **기계식 버튼의 물리적 한계**
    
    사용자는 버튼을 "딱!" 한 번 누른다고 생각하지만, 실제로는:
    
    ```
    [이상적 신호]: 0 ───────→ 1 (깔끔하게 한 번)
    
    [실제 신호]:   0 ─┐ ┌┐┌┐┌┐─→ 1 (10ms 동안 수십 번 떨림!)
                    └┘└┘└┘└┘
    ```
    
    **왜 이런 일이?**
    
    기계식 스위치를 누를 때, 금속 접점이 붙는 순간 미세한 떨림(탄성 진동)으로 인해 10ms 동안 수십 번의 Rising/Falling Edge가 반복된다.
    
    **문제점**:
    
    EXTI는 하드웨어적으로 너무 빠르고 정밀하기 때문에, 이 수십 번의 떨림을 모두 감지하여 ISR을 수십 번 호출해버리는 치명적 오류를 낳는다.
    
    ```
    사용자 의도: 버튼 1번 클릭
    실제 동작:  인터럽트 30번 발생!
    ```
    
    **해결책 (디바운싱, Debouncing)**:
    
    1. **하드웨어 방식**: RC 필터 회로
       - 저항(R)과 커패시터(C)를 사용하여 전압 변화를 부드럽게 만듦
       - 회로가 물리적으로 떨림을 흡수
    
    2. **소프트웨어 방식**: 시간 기반 필터링
       ```c
       volatile uint32_t last_interrupt_time = 0;
       
       void 버튼_인터럽트_핸들러() {
           uint32_t now = millis();
           
           // 마지막 인터럽트로부터 50ms 이내면 무시 (떨림으로 간주)
           if (now - last_interrupt_time < 50) {
               return;  // 무시!
           }
           
           last_interrupt_time = now;
           버튼_처리();  // 진짜 버튼 클릭만 처리
       }
       ```

 6. 실제 사용 예시
    ```c
    // 버튼(PA0)을 누르면 LED(PA5) 토글
    
    // 초기 설정
    attachInterrupt(PA0, 버튼_눌림, RISING);  // PA0 상승 에지에 인터럽트 연결
    
    // 평소 CPU는 다른 일 하는 중...
    void loop() {
        // 센서 읽기, 통신 처리, 계산 등...
    }
    
    // 버튼 누르면 자동 실행!
    void 버튼_눌림() {
        digitalWrite(PA5, !digitalRead(PA5));  // LED 반전
    }
    ```

## 3. GPIO 동작 (Operations)

### 3-1. 입력 상태 읽기 (Reading Input State)

#### 쉽게 이해하기

**판사와 증거 비유:**

GPIO 입력 읽기는 "법정의 판사"가 증거(전압)를 보고 판결(0 또는 1)을 내리는 것과 같다.

```
증거(전압)        판사(슈미트 트리거)의 판단
─────────────────────────────────────
0.5V             "확실한 0이다!" → 0
1.5V             "애매한데... 이전 판결 유지"
2.5V             "확실한 1이다!" → 1
```

**핵심:**
- 중간 전압(회색지대)이 들어오면 판단을 보류하고 이전 상태를 유지
- 덕분에 노이즈로 전압이 떨려도 값이 안정적!

```c
int button_state = digitalRead(12);  // 12번 핀 읽기
if (button_state == HIGH) {
    // 버튼이 눌림!
}
```

#### 1. 정의 (Definition)

**디지털 판독 (Digital Read):**

GPIO 핀에 인가된 **물리적인 전압(Analog Voltage)**을 MCU가 미리 정해진 기준에 따라 **논리적인 값(0 또는 1)**으로 변환하여 인식하는 과정이다.

**IDR (Input Data Register):**

MCU 내부에는 핀의 현재 상태가 실시간으로 저장되는 '입력 데이터 레지스터'가 있다. 우리가 코드로 Read 명령을 내리면, 실제로는 핀을 직접 보는 게 아니라 이 **IDR 메모리 번지의 값(비트)**을 읽어오는 것이다.

#### 2. 동작 메커니즘: 슈미트 트리거 (Schmitt Trigger)

**쉬운 설명:**

컴퓨터는 무조건 흑백논리(0 아니면 1)여야 한다. 하지만 현실의 전압은 애매한 중간값이 많다.

```
문제: 3.3V는 '1', 0V는 '0'인데... 1.5V는?
```

**슈미트 트리거 = 깐깐한 판사:**

MCU 입구에 서 있는 판사가 다음 규칙으로 판단한다:
- "전압이 2.0V 이상으로 **확실히** 올라가야 '1'로 인정한다." ($V_{IH}$)
- "전압이 0.8V 이하로 **확실히** 떨어져야 '0'으로 인정한다." ($V_{IL}$)
- 그 사이(0.8V ~ 2.0V)의 애매한 구간에서는 **"판단 보류(이전 상태 유지)"**

**기술적 설명:**

전압의 애매함: 3.3V가 '1'이고 0V가 '0'인 건 명확하지만, 만약 1.5V가 들어오면 이를 1로 판단할지, 0으로 판단할지가 문제다.

슈미트 트리거(Schmitt Trigger)가 이 문제를 해결한다:

```
V_IH (Input High Threshold): 이 전압 이상이면 '1'로 인정 (예: 2.0V)
V_IL (Input Low Threshold):  이 전압 이하면 '0'으로 인정 (예: 0.8V)
```

**히스테리시스 (Hysteresis):**

그 사이(0.8V ~ 2.0V)의 애매한 전압 구간에서는 **"판단 보류(이전 상태 유지)"**를 선언한다.

이 덕분에 노이즈 때문에 전압이 1.5V 근처에서 떨려도, MCU는 줏대 있게 0이나 1을 유지할 수 있다.

```
전압 변화:  0V → 1.5V → 2.5V → 1.5V → 0.5V
판독 결과:  0  →  0   →  1   →  1   →  0
              (유지)  (변경)  (유지)  (변경)
```

#### 3. 이유 및 실무 포인트

**3-1. 센싱 (Sensing):**

버튼이 눌렸는지, 센서가 물체를 감지했는지 알아내는 유일한 수단이다.

```c
if (digitalRead(BUTTON_PIN) == LOW) {  // Active Low 버튼
    LED_켜기();
}
```

**3-2. 마스킹 (Masking) 필요:**

보통 IDR 레지스터를 읽으면 16개 핀(0~15번)의 상태가 한꺼번에 16비트 데이터로 들어온다.

```
예: IDR = 0000 0000 0000 0101 (2진수)
    → 0번 핀 = 1, 2번 핀 = 1, 나머지 = 0
```

만약 '3번 핀' 하나만 궁금하다면, C언어의 **비트 연산자(&)**를 써서 나머지 비트는 가리고(Masking) 3번 비트만 쏙 뽑아내야 한다.

**코드 예시:**

```c
// 3번 핀의 상태만 확인
if ((GPIOx->IDR & (1 << 3)) != 0) {
    // 3번 비트가 1이라면?
    printf("3번 핀이 HIGH 상태입니다\n");
}

// 비트 마스킹 동작 원리:
// IDR = 0000 0000 0000 1101 (원본)
// (1<<3) = 0000 0000 0000 1000 (마스크)
// 결과 = 0000 0000 0000 1000 (3번 비트만 추출)
```

**3-3. 응용 예시:**

```c
// 여러 버튼 동시 읽기
uint16_t all_pins = GPIOx->IDR;  // 모든 핀 한 번에 읽기

bool button1 = (all_pins & (1 << 0)) != 0;  // 0번 핀
bool button2 = (all_pins & (1 << 1)) != 0;  // 1번 핀
bool button3 = (all_pins & (1 << 2)) != 0;  // 2번 핀

// 한 번의 레지스터 읽기로 여러 핀 확인 (효율적!)
```

### 3-2. 출력 설정(Set) / 해제(Clear)

#### 쉽게 이해하기

**전등 스위치 비유:**

GPIO 출력 제어는 집에 있는 전등 스위치를 켜고 끄는 것과 똑같다.

```
Set (설정):    스위치 ON  → 전등 켜짐 (3.3V 출력)
Clear (해제):  스위치 OFF → 전등 꺼짐 (0V 출력)
```

**실제 사용:**

```c
digitalWrite(13, HIGH);  // 13번 핀 켜기 (Set)
digitalWrite(13, LOW);   // 13번 핀 끄기 (Clear)
```

이렇게 하면 LED가 켜지고, 모터가 돌고, 릴레이가 작동한다!

#### 1. 정의 (Definition)

**Set (설정):**

GPIO 핀의 전압 레벨을 Logic High (1, VCC, 3.3V) 상태로 만드는 것.

**Clear (해제):**

GPIO 핀의 전압 레벨을 Logic Low (0, GND, 0V) 상태로 만드는 것.

MCU 내부적으로는 **ODR (Output Data Register)**이라는 메모리 주소의 특정 비트에 1 또는 0을 쓰는(Write) 행위다.

#### 2. 동작 메커니즘

**쉬운 설명: 스위치 조작**

**Set: "전등 스위치를 켜라!"**

핀에 연결된 회로에 전류가 흐르기 시작한다. (LED 켜짐, 모터 회전)

```c
PORTA |= (1 << 3);  // 3번 핀만 1로 만들기
```

**Clear: "전등 스위치를 꺼라!"**

핀에 연결된 회로에 전류가 끊어진다. (LED 꺼짐, 모터 정지)

```c
PORTA &= ~(1 << 3);  // 3번 핀만 0으로 만들기
```

**기술적 설명: Read-Modify-Write 과정**

위 코드(`|=`, `&=`)를 보면 알겠지만, 단순히 "3번 핀 켜!"라고 명령하는 게 아니다.

실제로는 다음 3단계를 거친다:

```
1. Read (읽기):    현재 모든 핀의 상태를 읽어온다
   PORTA = 0000 0101 (현재 0번, 2번 핀이 켜져 있음)

2. Modify (수정):  3번 비트만 1로 고친다
   0000 0101 | 0000 1000 = 0000 1101

3. Write (쓰기):   수정된 값을 다시 레지스터에 덮어쓴다
   PORTA = 0000 1101 (이제 0번, 2번, 3번 핀이 켜짐)
```

**주의할 점:**

이 복잡한 과정이 왜 문제일까? 

만약 Read와 Write 사이에 인터럽트가 끼어들어 다른 핀을 변경하면, 그 변경사항이 사라질 수 있다! (Race Condition)

이 문제는 **Atomic Operations**(원자적 연산)으로 해결한다. (다음 섹션에서 설명)

#### 3. 이유 및 실무 포인트

**3-1. Actuation (구동):**

LED 제어, 릴레이 동작, LCD 화면 켜기 등 모든 물리적인 제어의 기본이다.

```c
// LED 깜빡이기
digitalWrite(LED_PIN, HIGH);  // 켜기
delay(1000);
digitalWrite(LED_PIN, LOW);   // 끄기
delay(1000);
```

**3-2. 초기화 (Initialization):**

MCU가 켜지자마자 핀이 제멋대로 동작하면 안 된다. (예: 모터가 갑자기 윙~ 돌아가면 위험함)

그래서 Configuration 단계에서 **초기값(Initial State)**을 미리 Set(1) 또는 Clear(0)로 확실하게 정해둬야 한다.

```c
void setup() {
    pinMode(MOTOR_PIN, OUTPUT);
    digitalWrite(MOTOR_PIN, LOW);  // 초기값: 꺼진 상태로 시작!
    
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);    // LED도 꺼진 상태로 시작
}
```

**3-3. 실무 예시:**

```c
// 릴레이로 에어컨 제어
#define AC_RELAY_PIN 7

void 에어컨_켜기() {
    digitalWrite(AC_RELAY_PIN, HIGH);  // Set
    Serial.println("에어컨 ON");
}

void 에어컨_끄기() {
    digitalWrite(AC_RELAY_PIN, LOW);   // Clear
    Serial.println("에어컨 OFF");
}

// 비트 연산으로 직접 제어 (고급)
void 여러_핀_동시_제어() {
    // 3번, 5번, 7번 핀을 동시에 켜기
    PORTA |= (1 << 3) | (1 << 5) | (1 << 7);
    
    // 2번, 4번 핀을 동시에 끄기
    PORTA &= ~((1 << 2) | (1 << 4));
}
```

### 3-3. Toggle Operations (토글 / 반전)

#### 쉽게 이해하기

**똑딱이 볼펜 비유:**

Toggle은 "똑딱이 볼펜"을 누르는 것과 같다!

```
현재 상태를 확인할 필요 없이 그냥 누르기만 하면:
- 심이 나와 있으면 → 들어감
- 심이 들어가 있으면 → 나옴
```

**Set/Clear vs Toggle:**

```c
// Set/Clear: 상태를 명시적으로 지정
digitalWrite(13, HIGH);  // "켜!"
digitalWrite(13, LOW);   // "꺼!"

// Toggle: 현재 상태의 반대로
toggle(13);  // "반대로 해!"
```

**실제 사용:**

```c
// LED 깜빡이기
while(1) {
    toggle(LED_PIN);  // 켜짐 ↔ 꺼짐 반복
    delay(500);
}
```

#### 1. 정의 (Definition)

현재 핀의 상태를 반대로 뒤집는(Invert) 동작이다.

만약 현재 High(1)라면 Low(0)로, Low(0)라면 High(1)로 바꾼다.

C언어에서는 **XOR 연산자(^)**를 사용하여 구현한다.

```c
PORTA ^= (1 << 3);  // 3번 핀의 값을 반전시켜라
```

#### 2. 동작 메커니즘

**쉬운 설명: 똑딱이 볼펜**

**Set/Clear:** "볼펜 심을 꺼내라!", "볼펜 심을 넣어라!"라고 상태를 지정하는 것.

**Toggle:** "볼펜 뒤를 한 번 눌러라!"
- 지금 심이 나와 있으면 들어갈 것이고, 들어가 있으면 나올 것이다.
- 너는 현재 상태를 굳이 확인하지 않고 그냥 '누르기만(Action)' 하면 상태가 반대로 바뀐다.

**기술적 설명: XOR 비트 연산**

Toggle은 XOR(배타적 논리합) 연산을 사용한다:

```
XOR 진리표:
현재값  XOR  1   =  결과
  0    XOR  1   =   1   (반전됨)
  1    XOR  1   =   0   (반전됨)
```

**동작 과정:**

```c
// 3번 핀을 토글
PORTA ^= (1 << 3);

// 내부 동작:
// 1. Read:   PORTA = 0000 0101 (현재 0번, 2번 핀 켜짐)
// 2. XOR:    0000 0101 ^ 0000 1000 = 0000 1101
// 3. Write:  PORTA = 0000 1101 (3번 핀이 반전됨)
```

**주의점:**

토글 역시 "현재 상태를 읽어서(Read) → 뒤집고(Modify) → 다시 쓰는(Write)" 과정이다.

그래서 아주 빠른 속도로 토글하면, **RMW(Read-Modify-Write) 문제**가 발생할 수 있다. (Race Condition)

#### 3. 이유 및 실무 포인트

**3-1. Heartbeat (심장 박동):**

임베디드 장비가 살았는지 죽었는지 확인하기 위해 LED를 1초마다 깜빡거리게 만들 때 가장 많이 쓴다. (무한 루프에서 계속 토글)

```c
// 시스템 동작 확인용 LED
void loop() {
    // ... 메인 작업들 ...
    
    // 1초마다 LED 토글 (시스템이 살아있다는 증거)
    static uint32_t last_toggle = 0;
    if (millis() - last_toggle >= 1000) {
        digitalWrite(HEARTBEAT_LED, !digitalRead(HEARTBEAT_LED));
        last_toggle = millis();
    }
}
```

**3-2. 클럭 생성 (Square Wave):**

일정한 속도로 토글을 계속하면 **구형파(네모난 파형)**가 만들어진다. 이걸로 다른 칩에 클럭 신호를 공급하거나 부저(Buzzer) 소리를 낼 수 있다.

```c
// 1kHz 부저 소리 만들기
void beep_1kHz() {
    for (int i = 0; i < 1000; i++) {  // 1초 동안
        digitalWrite(BUZZER_PIN, HIGH);
        delayMicroseconds(500);  // 0.5ms
        digitalWrite(BUZZER_PIN, LOW);
        delayMicroseconds(500);  // 0.5ms
        // 총 1ms 주기 = 1kHz
    }
}

// 또는 토글 사용
void beep_1kHz_toggle() {
    for (int i = 0; i < 2000; i++) {  // 2000번 토글 = 1초
        toggle(BUZZER_PIN);
        delayMicroseconds(500);
    }
}
```

**3-3. 간결한 코드:**

Toggle을 사용하면 현재 상태를 확인하는 코드가 필요 없어 더 간결하다.

```c
// Toggle 없이 (복잡함)
if (digitalRead(LED_PIN) == HIGH) {
    digitalWrite(LED_PIN, LOW);
} else {
    digitalWrite(LED_PIN, HIGH);
}

// Toggle 사용 (간결함)
digitalWrite(LED_PIN, !digitalRead(LED_PIN));

// 또는 직접 비트 연산
PORTA ^= (1 << LED_BIT);
```

**3-4. 실무 예시:**

```c
// 버튼을 누를 때마다 LED 상태 반전
void button_interrupt_handler() {
    digitalWrite(LED_PIN, !digitalRead(LED_PIN));  // Toggle
    // 켜져있으면 꺼지고, 꺼져있으면 켜짐
}

// 디버깅용 핀 토글 (오실로스코프로 타이밍 측정)
void measure_execution_time() {
    digitalWrite(DEBUG_PIN, HIGH);  // 시작 표시
    
    complex_calculation();  // 측정하고 싶은 코드
    
    digitalWrite(DEBUG_PIN, LOW);   // 종료 표시
    // 오실로스코프로 HIGH 구간의 시간을 측정
}
```

### 3-4. Atomic Bit Operations (원자적 비트 조작)

#### 쉽게 이해하기

**은행 계좌 입출금 비유:**

**위험한 방식 (RMW):**
```
1. 통장 잔액 확인 (Read):      10,000원
2. 계산하기 (Modify):           10,000 + 5,000 = 15,000원
3. 통장에 쓰기 (Write):         15,000원

문제: 2번 하는 중에 다른 사람이 끼어들어 3,000원을 빼면?
     → 그 변경사항이 사라짐!
```

**안전한 방식 (Atomic):**
```
은행에게 "5,000원 입금해줘!" 한 마디로 끝.
→ 은행이 알아서 중간에 방해 없이 처리
```

**GPIO에서:**
```c
// 위험: Read-Modify-Write
PORTA |= (1 << 3);  // 읽고 → 수정하고 → 쓰기 (3단계, 끼어들 틈 있음)

// 안전: Atomic
BSRR = (1 << 3);    // 단 한 번에 쓰기만! (1단계, 끼어들 틈 없음)
```

#### 1. 정의 (Definition)

**Atomic (원자적):**

"더 이상 쪼갤 수 없는"이라는 뜻이다. 프로그래밍에서는 **"중간에 인터럽트(방해) 당하지 않고 한 번에 끝나는 명령어"**를 의미한다.

**BSRR (Bit Set/Reset Register):**

일반적인 ODR(출력 레지스터)을 읽고 고치는 게 아니라, **'설정 전용 레지스터(BSRR)'**에 1을 쓰기만 하면 하드웨어가 알아서 해당 핀을 즉시 변경해 주는 방식이다.

Read-Modify-Write (RMW) 과정 없이, **Write Only**로 핀을 제어하는 하드웨어적 기능이다.

#### 2. 동작 메커니즘: RMW의 비극 vs 원자적 해결

**상황 설정:**

0번 핀과 1번 핀이 둘 다 0인 상태(00)라고 가정해 보자.

**[위험한 방식] RMW (Read-Modify-Write)**

C언어로 `PORTA |= (1 << 0);` (0번 핀 켜기)를 실행하면, CPU는 실제로는 3단계로 일을 한다.

```
1. Read (읽기):
   현재 포트 상태(00)를 읽어서 CPU로 가져온다.
   
2. Modify (수정):
   가져온 값의 0번 비트를 1로 바꾼다. (01)
   
3. Write (쓰기):
   바뀐 값(01)을 다시 포트 레지스터에 쓴다.
```

**문제 발생 (Race Condition):**

```
시간 순서:
─────────────────────────────────────────────
메인 코드:    1. Read (00 읽음)
메인 코드:    2. Modify (01로 수정 중...)
                    ↓
            [인터럽트 발생!]
인터럽트:         1번 핀을 켠다 (포트 = 10)
            [인터럽트 종료]
                    ↓
메인 코드:    3. Write (아까 계산한 01을 씀)
─────────────────────────────────────────────
결과: 포트 = 01 (인터럽트가 켠 1번 핀이 꺼짐!)
기대: 포트 = 11 (둘 다 켜져야 함)
```

**데이터 소실 발생!** 인터럽트가 켰던 1번 핀이 다시 꺼져버린다.

**[안전한 방식] Atomic Operation (BSRR)**

```c
BSRR = (1 << 0);  // 0번 비트에 1을 쓴다
```

**동작:**
- "현재 상태가 뭐든 상관없어. 그냥 0번만 켜!"
- CPU는 **단 한 번의 명령어(Store)**로 명령을 끝낸다.
- 중간에 인터럽트가 끼어들 틈이 없다.

```
시간 순서:
─────────────────────────────────────────────
메인 코드:    BSRR에 (1<<0) 쓰기 [원자적 실행, 방해 불가]
                    ↓
            [이 순간 인터럽트가 와도 상관없음]
인터럽트:         1번 핀을 켠다 (독립적으로 동작)
─────────────────────────────────────────────
결과: 포트 = 11 (둘 다 정상적으로 켜짐!)
```

**STM32 BSRR 레지스터 구조:**

```
BSRR[31:16] = Reset 비트 (1을 쓰면 해당 핀 Clear)
BSRR[15:0]  = Set 비트 (1을 쓰면 해당 핀 Set)

예시:
GPIOA->BSRR = (1 << 3);   // 3번 핀 Set
GPIOA->BSRR = (1 << 19);  // 3번 핀 Clear (16 + 3)
```

#### 3. 이유 및 실무 포인트

**3-1. Race Condition (경쟁 상태) 방지:**

위에서 설명한 것처럼, 여러 설정이 동시에(멀티스레드, 인터럽트) 핀을 건드릴 때 데이터가 깨지는 것을 막아준다.

**RTOS(실시간 운영체제)**나 복잡한 펌웨어에서는 선택이 아니라 **필수**다.

```c
// 메인 루프에서
void main_loop() {
    GPIOA->BSRR = (1 << 5);  // LED 켜기 (원자적)
}

// 인터럽트 핸들러에서
void timer_interrupt() {
    GPIOA->BSRR = (1 << 6);  // 다른 LED 켜기 (원자적)
    // 서로 간섭하지 않음!
}
```

**3-2. 실행 속도:**

읽고 고치고 쓰는 3단계보다, 그냥 쓰는 1단계가 훨씬 빠르다!

```
RMW 방식:   Read(1사이클) + Modify(1사이클) + Write(1사이클) = 3사이클
Atomic:     Write(1사이클) = 1사이클

속도: 3배 빠름!
```

**3-3. 코드 비교:**

```c
// [나쁜 예] RMW - Race Condition 위험
void set_pin_unsafe() {
    GPIOA->ODR |= (1 << 3);  // 위험!
}

// [좋은 예] Atomic - 안전
void set_pin_safe() {
    GPIOA->BSRR = (1 << 3);  // 안전!
}

// [좋은 예] 여러 핀 동시 제어도 원자적으로
void set_multiple_pins() {
    GPIOA->BSRR = (1 << 3) | (1 << 5) | (1 << 7);  // 3, 5, 7번 핀 동시 Set
}

// [좋은 예] Set과 Clear를 동시에
void set_and_clear_pins() {
    GPIOA->BSRR = (1 << 3) |      // 3번 핀 Set
                  (1 << (5+16));  // 5번 핀 Clear
    // 한 번의 명령으로 두 동작!
}
```

**3-4. RTOS 환경에서의 필수성:**

```c
// FreeRTOS에서 두 개의 태스크가 동시에 실행
void Task1(void *param) {
    while(1) {
        GPIOA->BSRR = (1 << 0);  // 0번 핀 켜기 (원자적)
        vTaskDelay(100);
    }
}

void Task2(void *param) {
    while(1) {
        GPIOA->BSRR = (1 << 1);  // 1번 핀 켜기 (원자적)
        vTaskDelay(100);
    }
}
// BSRR 덕분에 서로 간섭 없이 안전하게 동작!
```

**3-5. 주의사항:**

모든 MCU가 BSRR을 지원하는 것은 아니다:
- **STM32:** BSRR 지원 ✓
- **AVR (Arduino Uno 등):** BSRR 없음 → 인터럽트 비활성화로 해결
  ```c
  cli();  // 인터럽트 끄기
  PORTA |= (1 << 3);  // 안전하게 조작
  sei();  // 인터럽트 켜기
  ```
- **ARM Cortex-M:** BSRR 또는 유사한 원자적 명령어 지원

## 4. GPIO 레지스터 및 설정 (Registers & Configuration)

### 4-1. ODR vs IDR vs BSRR 레지스터 비교

#### 쉽게 이해하기

**우체국 비유:**

```
IDR (Input Data Register):    우편함 확인 (읽기 전용)
ODR (Output Data Register):   편지 보내기 (읽기/쓰기)
BSRR (Bit Set/Reset Register): 빠른 택배 (쓰기 전용, 빠름!)
```

#### 레지스터 비교표

| 레지스터 | 용도 | 접근 방식 | 속도 | 안전성 | 사용 시기 |
|---------|------|----------|------|--------|---------|
| **IDR** | 입력 읽기 | Read Only | 보통 | 안전 | 버튼, 센서 상태 확인 |
| **ODR** | 출력 제어 | Read/Write | 느림 | 위험 (RMW) | 단순 출력 (인터럽트 없을 때) |
| **BSRR** | 출력 제어 | Write Only | 빠름 | 안전 (Atomic) | 멀티태스킹, 인터럽트 환경 |

#### 상세 설명

**1. IDR (Input Data Register)**

```c
uint16_t value = GPIOA->IDR;  // 포트 A의 모든 핀 상태 읽기

// 특정 핀만 확인
if (GPIOA->IDR & (1 << 3)) {
    // 3번 핀이 HIGH
}
```

- **특징:** 읽기 전용
- **용도:** GPIO 입력 상태 확인
- **주의:** 쓰기 시도 시 무시됨

**2. ODR (Output Data Register)**

```c
GPIOA->ODR = 0x00FF;  // 하위 8비트 모두 1로 설정

// 특정 비트 설정 (RMW 방식)
GPIOA->ODR |= (1 << 3);   // 3번 핀 Set
GPIOA->ODR &= ~(1 << 5);  // 5번 핀 Clear
```

- **특징:** 읽기/쓰기 가능
- **위험:** Read-Modify-Write로 Race Condition 가능
- **용도:** 단순 환경 (인터럽트 없는 메인 루프)

**3. BSRR (Bit Set/Reset Register)**

```c
// STM32 구조:
// BSRR[15:0]  = Set 비트 (1 쓰면 해당 핀 High)
// BSRR[31:16] = Reset 비트 (1 쓰면 해당 핀 Low)

GPIOA->BSRR = (1 << 3);      // 3번 핀 Set
GPIOA->BSRR = (1 << (5+16)); // 5번 핀 Reset

// 동시 Set/Reset
GPIOA->BSRR = (1 << 3) | (1 << (5+16));  // 3번 Set, 5번 Reset
```

- **특징:** 쓰기 전용, 원자적 실행
- **장점:** Race Condition 없음, 속도 빠름
- **용도:** RTOS, 인터럽트 환경 (필수!)

#### 성능 비교

```c
// 속도 측정 (STM32F4 기준)
// ODR 방식 (RMW):     ~3 사이클
// BSRR 방식 (Atomic): ~1 사이클

// 안전성:
// ODR:  인터럽트 환경에서 위험 ⚠️
// BSRR: 항상 안전 ✓
```

### 4-2. 포트 전체 읽기/쓰기

#### 쉽게 이해하기

**신호등 비유:**

개별 제어: 빨강, 노랑, 초록을 하나씩 켜기
포트 제어: 한 번에 "빨강+노랑 꺼, 초록 켜" 명령!

#### 용도 및 사용법

**포트 전체 읽기:**

```c
// 16개 핀 상태를 한 번에 읽기
uint16_t port_state = GPIOA->IDR;

// 비트 분석
bool pin0 = (port_state & (1 << 0)) != 0;
bool pin1 = (port_state & (1 << 1)) != 0;
// ...

// 패턴 확인
if ((port_state & 0x0F) == 0x05) {  // 하위 4비트가 0101인지
    // 특정 패턴 감지
}
```

**포트 전체 쓰기:**

```c
// 모든 핀 한 번에 설정
GPIOA->ODR = 0xAAAA;  // 1010 1010 1010 1010 패턴

// 또는 BSRR로 안전하게
GPIOA->BSRR = 0xAAAA0000;  // 하위 16비트는 Set, 상위는 Reset
```

**실제 활용 예시:**

```c
// 8비트 병렬 데이터 버스 (LCD 제어)
void write_parallel_data(uint8_t data) {
    // PA0~PA7에 데이터 출력
    uint16_t temp = GPIOA->ODR;
    temp &= 0xFF00;  // 상위 8비트 유지
    temp |= data;     // 하위 8비트에 데이터
    GPIOA->ODR = temp;
}

// 7-Segment Display (여러 핀 동시 제어)
const uint8_t digit_patterns[10] = {
    0x3F, 0x06, 0x5B, 0x4F, 0x66,  // 0~4
    0x6D, 0x7D, 0x07, 0x7F, 0x6F   // 5~9
};

void display_digit(uint8_t num) {
    if (num > 9) return;
    GPIOB->ODR = digit_patterns[num];  // 한 번에 패턴 출력
}
```

### 4-3. GPIO 초기화 순서

#### 쉽게 이해하기

**자동차 시동 순서와 비유:**

```
1. 키 꽂기         → 클럭 활성화 (전원 공급)
2. 기어 확인       → 모드 설정 (입력/출력)
3. 핸들 조정       → 속도/드라이브 설정
4. 시동 걸기       → 초기값 설정
```

순서를 틀리면 시동이 안 걸리듯, GPIO도 순서가 중요!

#### 표준 초기화 순서

**1단계: 클럭 활성화**

```c
// STM32 예시
RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;  // GPIOA 클럭 켜기

// 클럭이 안정화될 때까지 대기 (보통 필요 없지만 안전하게)
volatile uint32_t dummy = RCC->AHB1ENR;  // Read back
```

**2단계: 모드 설정 (Input/Output/AF/Analog)**

```c
// PA3를 출력으로 설정
GPIOA->MODER &= ~(0x3 << (3*2));  // 해당 비트 클리어
GPIOA->MODER |= (0x1 << (3*2));   // 01 = 출력 모드
```

**3단계: 출력 타입 설정 (Push-Pull/Open-Drain)**

```c
GPIOA->OTYPER &= ~(1 << 3);  // 0 = Push-Pull
// GPIOA->OTYPER |= (1 << 3);  // 1 = Open-Drain
```

**4단계: 속도 설정**

```c
GPIOA->OSPEEDR &= ~(0x3 << (3*2));
GPIOA->OSPEEDR |= (0x2 << (3*2));  // 10 = High Speed
```

**5단계: 풀업/풀다운 설정**

```c
GPIOA->PUPDR &= ~(0x3 << (3*2));
GPIOA->PUPDR |= (0x1 << (3*2));  // 01 = Pull-up
```

**6단계: 초기 출력값 설정**

```c
GPIOA->BSRR = (1 << (3+16));  // 초기값 LOW로 시작 (안전)
```

#### 완전한 초기화 함수 예시

```c
void GPIO_Init_PA3_Output(void) {
    // 1. 클럭 활성화
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    
    // 2. 모드: 출력
    GPIOA->MODER &= ~(0x3 << (3*2));
    GPIOA->MODER |= (0x1 << (3*2));
    
    // 3. 타입: Push-Pull
    GPIOA->OTYPER &= ~(1 << 3);
    
    // 4. 속도: Medium
    GPIOA->OSPEEDR &= ~(0x3 << (3*2));
    GPIOA->OSPEEDR |= (0x1 << (3*2));
    
    // 5. 풀업/풀다운: None
    GPIOA->PUPDR &= ~(0x3 << (3*2));
    
    // 6. 초기값: LOW
    GPIOA->BSRR = (1 << (3+16));
}
```

**주의사항:**

- 클럭을 먼저 켜지 않으면 나머지 설정이 무시됨!
- 초기값을 설정하지 않으면 불확정 상태로 시작 (위험)
- 모드 설정 전에 출력값을 쓰면 무시됨

### 4-4. GPIO Lock 메커니즘

#### 쉽게 이해하기

**자물쇠 비유:**

```
일반 설정: 자유롭게 문 열고 닫기
Lock 설정: 자물쇠로 잠금 → 리셋 전까지 열 수 없음!
```

중요한 핀(모터, 안전 장치)은 실수로 설정 변경되면 위험하니까 잠가둠!

#### 정의

GPIO Lock은 특정 핀의 설정(모드, 속도, 타입 등)을 **"동결"**시켜서 실수나 버그로 인한 변경을 방지하는 하드웨어 보호 기능이다.

한 번 Lock되면 **MCU 리셋 전까지** 해제 불가능!

#### 동작 원리

**Lock 시퀀스 (STM32 기준):**

```c
// 특정 순서로 LCKR 레지스터에 쓰기
void GPIO_Lock_Pin(GPIO_TypeDef *GPIOx, uint16_t pin) {
    uint32_t temp = GPIO_LCKR_LCKK | (1 << pin);
    
    // Lock 시퀀스 (매뉴얼에 정의된 순서 필수!)
    GPIOx->LCKR = temp;           // LCKK=1, 핀 비트 설정
    GPIOx->LCKR = (1 << pin);     // LCKK=0
    GPIOx->LCKR = temp;           // LCKK=1
    temp = GPIOx->LCKR;           // Read back (Lock 확인)
    
    // Lock 성공 확인
    if (GPIOx->LCKR & GPIO_LCKR_LCKK) {
        // Lock 성공!
    }
}
```

**사용 예시:**

```c
void Safety_Critical_Init(void) {
    // 1. 모터 제어 핀 설정
    GPIO_Init_Motor_Pin();
    
    // 2. 설정 완료 후 Lock!
    GPIO_Lock_Pin(GPIOA, 5);  // PA5 잠금
    
    // 3. 이제 아무도 PA5 설정을 바꿀 수 없음
    // GPIOA->MODER ... 시도해도 무시됨!
}
```

#### 언제 사용하는가?

**1. 안전 필수 시스템:**
- 자동차 ECU (모터, 브레이크)
- 의료 기기 (펌프, 밸브)
- 산업 제어 (비상 정지)

**2. 인증 시스템:**
- MISRA-C, IEC 61508 같은 안전 표준 준수

**3. 멀티 개발자 환경:**
- 실수로 중요 핀 설정 변경 방지

#### 주의사항

```c
// ⚠️ 한 번 Lock하면 리셋 전까지 해제 불가!
GPIO_Lock_Pin(GPIOA, 3);

// 이후 설정 변경 시도는 모두 무시됨
GPIOA->MODER |= (0x3 << (3*2));  // 무시됨!
GPIOA->OSPEEDR |= (0x3 << (3*2));  // 무시됨!

// 해제 방법: MCU 리셋만 가능
NVIC_SystemReset();
```

### 4-5. 입력 필터링 (Hardware Input Filtering)

#### 쉽게 이해하기

**물 정수기 비유:**

```
필터 없음: 흙탕물 그대로 들어옴 (노이즈 포함)
필터 있음: 깨끗한 물만 통과 (안정된 신호)
```

GPIO 입력도 전기적 노이즈를 하드웨어 필터로 걸러냄!

#### 정의

**Hardware Input Filter**는 GPIO 핀으로 들어오는 신호에서 짧은 글리치(Glitch)나 노이즈를 하드웨어적으로 제거하는 기능이다.

소프트웨어 디바운싱 없이도 깨끗한 신호를 얻을 수 있다.

#### 필터 종류

**1. 디지털 필터 (Digital Filter):**

```c
// STM32 일부 모델
// 연속 N번 같은 값이 읽혀야 변화 인정
// (설정 가능: 1~255 샘플)
```

**2. 아날로그 필터 (Analog Filter):**

일부 MCU는 핀 내부에 RC 필터 내장

**3. 하이스테리시스 (Hysteresis):**

슈미트 트리거의 $V_{IH}$와 $V_{IL}$ 차이로 자연스러운 필터링

#### 사용 예시

```c
// STM32 예시 (일부 모델)
// 필터 활성화
GPIOA->AFR[0] |= GPIO_AFRL_AFSEL3_FILTER;  // PA3 필터 활성화

// 필터 샘플 수 설정 (가상 코드)
FILTER->SAMPLES = 5;  // 5번 연속 같은 값이어야 변화 인정
```

**효과:**

```
필터 OFF:
신호: _____|‾‾|__|‾‾‾‾‾‾  (글리치 포함)
읽기: 0000011001111111     (잘못된 에지 감지)

필터 ON:
신호: _____|‾‾|__|‾‾‾‾‾‾
읽기: 000000000111111      (안정적)
```

#### 실무 활용

**버튼 입력:**
```c
// 필터를 켜면 하드웨어가 디바운싱 해줌
// 소프트웨어 delay 불필요!
```

**센서 신호:**
```c
// 노이즈가 많은 환경 (모터 근처)에서 유용
```

#### 한계 및 주의점

- 모든 MCU가 지원하는 것은 아님 (데이터시트 확인 필수)
- 필터 때문에 신호 지연이 생김 (보통 수 마이크로초)
- 초고속 신호는 필터링 불가능

## 5. 전기적 특성 (Electrical Characteristics)

### 쉽게 이해하기

**문 높이 비유:**

```
V_IH: "이 높이 이상이면 들어와도 돼" (2.0V)
V_IL: "이 높이 이하면 나가야 돼" (0.8V)
```

전압이 애매하면 "회색 지대" → 판단 보류!

### 주요 파라미터 (Quick Reference)

| 파라미터 | 의미 | 일반적 값 (3.3V 시스템) | 중요도 |
|---------|------|----------------------|--------|
| $V_{IH}$ | Input High 최소 전압 | 2.0V | ★★★ |
| $V_{IL}$ | Input Low 최대 전압 | 0.8V | ★★★ |
| $V_{OH}$ | Output High 최소 전압 | 2.4V | ★★★ |
| $V_{OL}$ | Output Low 최대 전압 | 0.4V | ★★★ |
| $I_{OH}$ | Output High 최대 전류 | 4~25mA | ★★ |
| $I_{OL}$ | Output Low 최대 전류 | 4~25mA | ★★ |
| $I_{leak}$ | Input 누설 전류 | < 1μA | ★ |

### 상세 설명

**입력 문턱 전압:**

```
3.3V ─┐
      │
V_IH ─┤─── 이 위는 확실히 HIGH (1)
      │
      │    ← 회색 지대 (히스테리시스)
      │
V_IL ─┤─── 이 아래는 확실히 LOW (0)
      │
0V  ──┘
```

**출력 능력:**

```c
// $I_{OH}$ = 8mA 라면
// LED 1개 (20mA 필요) → 직접 구동 불가 ✗
// LED 1개 (5mA)       → 가능 ✓
// 여러 개 병렬        → 불가 ✗
```

### 실무 체크리스트

```c
// ✓ 데이터시트에서 확인할 것들:
// 1. V_DD 범위 (2.0~3.6V?)
// 2. 5V 톨러런트 핀인가? (3.3V 시스템에 5V 연결 가능?)
// 3. 최대 출력 전류 (LED 직접 구동 가능?)
// 4. 전체 포트 최대 전류 (모든 핀 합산)
```

**참고:** 자세한 전기적 사양은 `00. Hardware Fundamentals > 0.3 Digital Logic & Interface`에서 확인하세요.
